{"posts":[{"title":"cPointerBk","text":"目录 目录 3.应用案例 3.1 数组和指针 3.2 字符数组和指针 3.3 指针和多维数组 4. 指针和动态内存 3.应用案例3.1 数组和指针 数组A[i]其中直接A保存的是数组的首地址，因此可以对其自增，自增的结果即是按变量类型进行地址的偏移 &amp;A[i] == A+i 数组元素的地址可以通过指针偏移得到 A[i] == *(A+i) 数组的值也可以通过指针偏移解引用得到 注意不要用A++实现数组偏移，因为声明了数组A之后，其变量名为const类型，不允许自增，可以A[i++]，此外还可以用*p = A，再 p++，这样是合法的。 数组传参到另一个函数的时候，在堆栈上的体现并不是像变量一样拷贝了一份，而是仅拷贝了数组的首地址指针。也就是说传数组其实是传引用（指针）那么函数参数可以写成int* A而不是int A[] 3.2 字符数组和指针 基本认识 - 字符串数组末端要有\\0，现代某些编译器会自动加，如果不会就需要自己处理 深刻理解数组不能自增寻址，而用指针进行间接自增寻址 例如 char A[10] 不能直接 A++ 得到下一个元素，而可以通过 char *C = A -&gt; C++ 的方式得到下一个元素 注意：char A[20] = &quot;Hello&quot; 虽然和 char *A = &quot;Hello&quot; 最后在Printf函数中打印出来的结果是一致的，但是后者被分配到了常量区，而不是变量区，不可以进行读写 ，也就说明数组是const类型的指针 3.3 指针和多维数组 1.由上面的数组和指针我们可以知道，数组是const类型的指针集合。 2.通过下面这个例子来了解多维数组和指针和解应用之间的嵌套关系 12345678910int B[2][3] = {{2,3,6},{4,5,8}};int (*p)[3] = B; // 此时p就是指向B[0]的地址的指针// B会返回一个一维数组B == (*p)[3]*B == B[0] == &amp;B[0][0]// 二维数组B的首地址就是B，也是B[0]所存的内容是个地址，这个地址就是B[0][0]在内存中的位置。// 所以对B进行解引用得到的元素是B[0][0]的地址// 得到B[0][0]的数值*(*B) == B[0][0] 4. 指针和动态内存","link":"/2023/06/29/cPointerBk/"},{"title":"第一篇博客","text":"Update Through Github Actions","link":"/2023/06/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"}],"tags":[],"categories":[],"pages":[]}