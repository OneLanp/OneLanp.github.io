{"posts":[{"title":"C指针","text":"I. 目录 I. 目录 1. 指针概述 1.1 基本概念 1.2 注意事项 1.3 使用场景 1.3.1 无返回值，处理main内局部函数 2.数组和指针 2.1 一般数组和指针 2.2 字符数组和指针 2.3 指针和多维数组 3. 指针和动态内存 1. 指针概述1.1 基本概念 指针变量的内容是某变量（数组）的地址（首地址）。 对*p进行自增（自减）操作时，其按照声明的对应变量类型的大小进行自增（自减） &amp; - 取地址， * - 解引用 指针是可以多重嵌套的，由此引申出多重指针，如下示例 123456789int a = 5;//类似于积分int* p = &amp;a;int** p0 = &amp;p;int*** p1 = &amp;p0;//类似于求导*p1 == &amp;p;*(*p1) == &amp;a; *(*(*p1)) == 5; 程序内存的分布主要为四大块，堆、栈、Static/Global、Code Code - 代码的存储空间 Static/Global - 全局变量的存储空间 Stack - 局部变量、程序运行时的函数地址、变量参数等的存储空间 Heap - 1.2 注意事项 声明的指针类型要与所保存地址的变量类型一致，否则编译器会报错，需要强制类型转换。 强制类型转换会导致数据的截断。 int* p = &amp;a;这个方式的*并不是解引用，而是声明指针变量并初始化。 指针的类型除了对应变量的类型之外，还有void Table 1 - 变量、指针类型的Sizeof 指针类型 int* char* float* double* void* Sizeof(Byte) 8 8 8 8 8 变量类型 int char float double Sizeof(Byte) 4 1 4 8 1.3 使用场景1.3.1 无返回值，处理main内局部函数 通过设置函数传参为指针变量，那么就可以通过解引用的方式对main函数内的局部变量在另一个函数内处理，而不需要使用return。 优点： 不需要创建全局变量，节省内存 123456789101112131415161718/** 功能：通过解引用的方式修改main函数内局部变量的值*/void incA(int *p){ *p = (*p)++;}int main(){ int a = 5; int* p = &amp;a; incA(p); printf(&quot;After incA the value of a is: %d \\r\\n&quot;);} 2.数组和指针2.1 一般数组和指针 数组A[i]其中直接A保存的是数组的首地址，因此可以对其自增，自增的结果即是按变量类型进行地址的偏移 &amp;A[i] == A+i 数组元素的地址可以通过指针偏移得到 A[i] == *(A+i) 数组的值也可以通过指针偏移解引用得到 注意不要用A++实现数组偏移，因为声明了数组A之后，其变量名为const类型，不允许自增，可以A[i++]，此外还可以用*p = A，再 p++，这样是合法的。 数组传参到另一个函数的时候，在堆栈上的体现并不是像变量一样拷贝了一份，而是仅拷贝了数组的首地址指针。也就是说传数组其实是传引用（指针）那么函数参数可以写成int* A而不是int A[] 2.2 字符数组和指针 基本认识 - 字符串数组末端要有\\0，现代某些编译器会自动加，如果不会就需要自己处理 深刻理解数组不能自增寻址，而用指针进行间接自增寻址 例如 char A[10] 不能直接 A++ 得到下一个元素，而可以通过 char *C = A -&gt; C++ 的方式得到下一个元素 注意：char A[20] = &quot;Hello&quot; 虽然和 char *A = &quot;Hello&quot; 最后在Printf函数中打印出来的结果是一致的，但是后者被分配到了常量区，而不是变量区，不可以进行读写 ，也就说明数组是const类型的指针 2.3 指针和多维数组 1.由上面的数组和指针我们可以知道，数组是const类型的指针集合。 2.通过下面这个例子来了解多维数组和指针和解应用之间的嵌套关系 12345678910int B[2][3] = {{2,3,6},{4,5,8}};int (*p)[3] = B; // 此时p就是指向B[0]的地址的指针// B会返回一个一维数组B == (*p)[3]*B == B[0] == &amp;B[0][0]// 二维数组B的首地址就是B，也是B[0]所存的内容是个地址，这个地址就是B[0][0]在内存中的位置。// 所以对B进行解引用得到的元素是B[0][0]的地址// 得到B[0][0]的数值*(*B) == B[0][0] 3. 指针和动态内存","link":"/2023/06/29/C%E6%8C%87%E9%92%88/"},{"title":"第一篇博客","text":"Update Through Github Actions","link":"/2023/06/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"}],"tags":[],"categories":[],"pages":[]}